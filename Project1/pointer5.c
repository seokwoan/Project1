#include <stdio.h>

int* init() {

	static int a[3] = { 11, 22, 33 };
	static int b[5] = { 50, 40, 88 , 99 ,81 };
	static int* p[2] = { a, b };
	// 함수에서 생성한 변수를 정적변수로 만들어줘야 한다
	return p;
}

void main() {


	// 포인터배열 : 포인터 변수가 연속적으로 되어있는 메모리공간

	//int* p2 = init(); // p의 1번 인덱스에는 a배열의 주소가 들어있다 -> 주소가 2개가 있다. 포인터배열의 주소는 2차원 포인터변수로 만들어줘야한다
	//printf("%d %d \n", p2[0][1]); // 포인터배열을 1차원 포인터변수로 받아서 2번째 인덱스의 주소를 찾지 못해서 오류가 난다

	int** p2 = init(); // 2차원 포인터 변수는 연산자를 2개 넣어준다
	printf("%d %d \n", p2[0][1], p2[1][2]); // 포인트배열을 2차원 포인터변수로 받아서 정상적으로 동작함
	printf("%d \n", p2[1][1]);
	
	printf("*p2+1 -> %p\n", *(p2 + 1)); // p2가 a의 메모리주소 -> a의 메모리주소에서 한칸 움직인 곳의 값을 가져오면 b의 메모리주소가 나옴
	printf("%p\n", (*p2) + 2);
	printf("%p\n", &p2[0][2]);

	printf("99 주소 -> %p\n", *(p2 + 1) + 3); // 99의 주소값

	printf("\n정리\n");

	printf("p의 주소 %p\n", p2); // p2에는 p의 메모리주소가 있음
	printf("a의 주소 %p\n", *p2); // p의 메모리주소에 있는 데이터 값은 a의 메모리주소 -> p[0]에는 a의 메모리 주소가 들어있음
	printf("b의 주소 %p\n", *(p2 + 1)); // p의 메모리주소에서 +1을한 주소는 b의 메모리주소 -> p[1]에는 b의 메모리 주소가 들어있음
	printf("a[1]의 주소 %p\n", *p2 + 1 ); // p2에있는 데이터값( a[0]의 메모리주소 )에 +1을한 주소는 a[1]의 메모리 주소
	printf("a[2]의 주소 %p\n", *p2 + 2);
	printf("b[1]의 주소 %p\n", *(p2 + 1) + 1);// (p2 + 1)에있는 데이터값( b[0]의 메모리주소 )에 +1을한 주소는 b[1]의 메모리 주소
	printf("b[2]의 주소 %p\n", *(p2 + 1) + 2);
	printf("b[3]의 주소 %p\n", *(p2 + 1) + 3);
	



	int* pa[5];

	int num = 10;
	pa[0] = &num;
	int arr[3] = { 10, 20, 30 };
	pa[1] = arr;

	printf("%d\n", *pa[0]); 
	// pa[0] 은 메모리주소를 표현함 *참조연산자를 붙여야 데이터값인 10이 나온다
	// 변수의 주소이기에 필요

	printf("%d\n", pa[1][2]); // *(pa[1]+2) -> pa[1]인덱스의 주소에서 2번 이동한 주소의 값을 참조연산자를 통해 나타냄
	// pa[1]은 배열의 주소를 나타내므로 참조연산자없이 인덱스로 값을 나타냄

	int arr2[10] = { 100, 500, 431, 5489 };
	pa[2] = arr2;

	printf("%d\n", pa[2][2]);

}

